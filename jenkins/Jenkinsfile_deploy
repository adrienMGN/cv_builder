pipeline {
    agent any
    
    environment {
        // IP de la machine où tourne le conteneur Registry
        REGISTRY = "100.77.150.49:5000"
        VITE_API_URL = "http://152.228.130.229:30001"
        // Chemin vers le kubeconfig récupéré du master
        KUBECONFIG_PATH = "${WORKSPACE}/kubeconfig-k3s"
    }

    stages {
        stage('Build & Push Backend') {
            steps {
                script {
                    dir('backend') {
                        // On utilise --network host si le registry est sur la même machine que Jenkins
                        sh "docker build -t ${REGISTRY}/cv-backend:latest ."
                        sh "docker push ${REGISTRY}/cv-backend:latest"
                    }
                }
            }
        }

    stage('Build & Push Frontend') {
                steps {
                    script {
                        echo "Building Frontend from Root..."
                        // On ne change pas de répertoire (pas de dir('frontend'))
                        // car le Dockerfile est à la racine.
                        sh "docker build --build-arg VITE_API_URL=${VITE_API_URL} -t ${REGISTRY}/cv-frontend:latest ."
                        sh "docker push ${REGISTRY}/cv-frontend:latest"
                    }
                }
            }

        stage('Prepare Kubeconfig') {
            steps {
                // On récupère le config du master pour pouvoir piloter le cluster depuis Jenkins
                sshagent(['master-specific-key']) {
                    sh """
                        scp -o StrictHostKeyChecking=no ubuntu@100.120.92.90:/etc/rancher/k3s/k3s.yaml ${KUBECONFIG_PATH}
                        sed -i 's/127.0.0.1/100.120.92.90/g' ${KUBECONFIG_PATH}
                        chmod 600 ${KUBECONFIG_PATH}
                    """
                }
            }
        }

        stage('Kubernetes Deploy') {
                    steps {
                        script {
                            echo "Applying K8s manifests..."
                            // Ajout du flag --insecure-skip-tls-verify=true
                            sh "kubectl --kubeconfig=${KUBECONFIG_PATH} --insecure-skip-tls-verify=true apply -f k8s/app-full.yaml"
                            
                            echo "Restarting deployments..."
                            sh "kubectl --kubeconfig=${KUBECONFIG_PATH} --insecure-skip-tls-verify=true rollout restart deployment/frontend"
                            sh "kubectl --kubeconfig=${KUBECONFIG_PATH} --insecure-skip-tls-verify=true rollout restart deployment/backend"
                        }
                    }
                }
    }
    
    post {
        success {
            echo "Déploiement terminé avec succès."
        }
        always {
            // Sécurité : on supprime le kubeconfig temporaire
            sh "rm -f ${KUBECONFIG_PATH}"
        }
    }
}
